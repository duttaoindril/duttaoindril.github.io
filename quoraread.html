Probably the best question I have seen in Quora so far. I like it because it forces the writer to confess their unpopular opinions and unpopular opinions are always very, very constructive because we can always learn something from those that see things different.

Having in mind that I am on the record here are some of my very unpopular opinions about software development. I will only focus in views that I know are not popular, feel free to rip my skin and call me names.

Java sucks, big time. A language created to control home appliances becomes the industry standard, what can go wrong? Java is clearly the COBOL of the future. Big, ugly and standard. I’m even scared to think what can replace Java considering what replaced COBOL.
Git is horrible. Your beloved,standard, source management system is poorly designed, obscure and hard to learn. And the worst thing is that it was done this way on purpose. The whole idea behind git is to make version control as difficult and obscure as possible to make it impossible for newbies to adopt. CVS had some problems but it was a lot more consistent in terms of commands and usage.
The OOP adoption in the industry is sustained by fear. OOP was adopted because it allows organizations to hire cheap programmers asking them to do small things while some master “architect” has the masterplan for the whole application. This is just the product of fear, many amazing pieces of software were done by a single expert programmer/hacker. Managers don’t like genius programmers/hackers, they tend to do whatever they want and they are expensive. Pity because they also tend to produce amazing software.
95% of the field known as Software Engineering is a bluff. Models, frameworks, architectures, managers, designers, analysis, they do absolutely nothing. Tell me a real reason for UML to exist. There’s a whole industry built by those that can’t or don’t want to code and the irony is that they have concocted the idea of “growing” to stop programming which is quite strange considering that if everybody “grows” or achieves perfection then software is not going to get done magically. Imagine a hospital where people without any idea of medicine would be in charge of doctors telling them what they have to do, this is how the software industry is run. You tell me you are a “designer” or a “functional analyst” I hear you can’t code. Period.
You can’t argue with success. Let’s say you decide to start an application doing everything you are not supposed to do, you eschew best practices, you select a language that, they say, only infra humans would use, you decide not to use the popular framework or the popular “methods”.The result? You end up building a thing called Facebook. I have a lot of respect for people that “do”, and I have my doubts about people commenting how things should be done. “I know this is all wrong but I fear it might be right”
Design Patterns are evil, really. It is very hard for me to imagine why a metal-duper-fabricator-insulator-interface pattern can be good. This insanity has to stop. Thompson didn’t know anything about patterns, he built Unix.
Pre-optimization is perfectly fine. You want to be unpopular? Go against Donald Knuth! I really mean this, when Knuth told this famous quote there was no Internet or BigData. Today scaling is frequently more important than the way to solve the problem. It is very common to start thinking about how the code will scale before even thinking about a solution for the problem, if you leave optimization for the end you might end up finding your beautiful code can run in 23 years instead of 207, and now what?
Simplicity is beautiful, simplicity is losing. A young programmer enters a company, he is asked to learn the “architecture” of the system, then he has to learn the “coding practices”, the “framework”, then the “test suites”, he is introduced to “sprints” and “code reviews”, when you finally write a line of code you are afraid you are violating 105 policies, breaking the practices and not making use of the framework. Now let’s say the young programmer is Dennis Ritchie who comes back with a time machine, he would be completely useless in most software companies today, he wouldn’t be able or allowed to do anything. Is this right? I don’t think so.
Programming Languages have not made any progress. C, Fortran and several other languages were developed in the 70’s. Back then programming was just writing one line of code after the other using a text editor. 40 years later programming is exactly the same. You can say you have a magna-composer class of your interscalable framework but you still write code with a text editor one line after the other.
LISP is still nice. More than 50 years after its creation the language is still beautiful. From the simple abstraction “everything is a list” to the way you can change the whole language if you want using macros. In LISP if you have an elipse and you set both axes to the same length the object can become a circle. Why? Because It IS a circle. Do that in Java. Good luck!
I reserve the right to continue this list, I’m sure I will produce more unpopular opinions and I will be reading your unpopular views.

<br><br>

Oh boy, brace for impact!

C++ is trash. It is only popular because C was popular. If you're looking for a C++ done right, check out the D programming language.
JavaScript is trash, but TypeScript could be the future. TypeScript is a superset of JavaScript that compiles to JS. I absolutely love TS (adds everything that JS lacks—static explicit typing, classes, etc.) and with some effort, we could make it into the new JavaScript.
Dynamic typing is never the answer. It leads to confusing code, hard-to-catch errors, and anything using dynamic typing can be replaced with a clearer version that is static typed. I have used C# for years and never have I needed to use dynamic types. Same in Python, and JS’s typing system is purely godawful.
OOP is good, but it is far from necessary. Sure it can make your code cleaner, but it can also make your code much more verbose. Additionally, it can be very hard to use if you don't use it correctly. In several instances, I've found more luck in a purely procedural atmosphere. This isn't to say I don't know how to use OOP (I'm very familiar with the concept and am not a stranger to using it), but sometimes it just isn't the best choice.
With proper documentation, code golf isn't a bad option in some cases. Yes, in most cases it's definitely clearness over conciseness, but there are some cases where optimal conciseness is the answer, even if readability suffers.
Well, there goes my reputation in the programming community, along with any chances of ever getting a job at Microsoft. Hope you enjoyed!

<br><br>

We don’t know how to manage teams. There hasn’t been any real progress made in the field since “Peopleware” was updated in 1999, and that mostly just confirms things in the 1987 edition, which only made minor additional discoveries on top of “The Mythical Man Month”, published in 1975. Everything else people claim to know about software engineering has not been validated. This includes all agile development.
There are no 10x engineers. There are people who can program and people who cannot, experienced and inexperienced, expert and non-expert, but no-one is unchangeably 10x more productive. What is true is that the highest reported level of productivity is 10x the productivity of the lowest performing people who get the job done. What determines this, however, is quiet and lack of interruption, not individual skills.
Your favorite language sucks. Programming language design is mostly ad-hoc, much more personal preference than science, and there are always much more important considerations anyway. Regardless of which language it is that you love, there are cases you should never use it in. But some languages should never be used for anything ever. Smalltalk is an amazing language, but you should almost never use it. JavaScript is a terrible language, but you have to use it.
Abstraction actually opposes re-use. The more abstracted a piece of software is, the less re-usable it is because it makes unalterable decisions that you may not want. Re-usable software components have high cohesion and low coupling, but this is not the same as being abstracted.
Pure programming skill is currently over-valued. Most people cannot learn to program. However, once someone demonstrates that they can program, higher levels of skill are of relatively little value most of the time. The skills needed to pass Google interview, for example, are substantially higher than needed to do most programming jobs, including programming jobs at Google. Domain expertise, communication skills, work ethic and so on are far more valuable than the ability to solve arbitrary dynamic programming puzzles.

<br><br>

Rule #1: Developers aren’t that smart: Lots of people here think OOP is overrated. Y’know what? OOP is great. But it’s not easy to do right, and most developers aren’t capable of doing it right. So it gets a bad name.

Lots of people here think Language X, methodology Y, or tool Z suck, but virtually none of them can build or even specify a better language, method, or tool. Is D a better C++, when they have 99% in common? Really? And how to explain the contradictory submissions to this question. Can both opposing opinions be right?

Premature optimization is only not evil if it doesn’t cost anything. If you spend weeks optimizing something that didn’t need it, that’s unambiguously dumb. But my thesis is that many developers wouldn’t know a waste of time if it kept them working 60 hour weeks.

Rule #2: Most Startups fail: When I say most, I mean like 95% are abject failures, yielding no product and consuming millions of dollars. Four per cent produce products that make some amount of money, but don’t result in anything more than wages for the early team. And yes, one per cent make you rich. This is enough for venture capitalists, but for developers, going with a startup is a worse bet than putting a years’ paychecks on a single roulette number. That developers can still be convinced to sign on to low pay and high equity in a startup is ample evidence for rule number 1 above.

Have you ever met a serial entrepreneur? Why aren’t they still managing the billion-dollar empire they created? Usually they have a single success that has funded subsequent failures. Some have never succeeded in anything but fast-talking VCs out of startup money, and developers out of quitting. Know how to make a small fortune in Silicon Valley? Start out with a big fortune.

Rule #3: Business plans are harder to write than software: The reason for rule #2 is that imagination is in such short supply when creating business plans. Most startup plans fall into just a few categories

The Internet of X, the Uber of Y, or the Facebook of Z, etc., where X, Y, and Z are randomly chosen market segments. Yeah, every now and then, you may find a winning combo at random (the Facebook of job seekers is called LinkedIn, for instance). But you have to be really fast to apply a known business model first, and there may be good reasons why no one else is in that space.
Sell the same thing that (Microsoft, Amazon, Google, etc) sells, competing against a giant on his home turf, because we’re so smart and they’re such idiots. The weakness in this plan is thinking that giants are necessarily idiots, or that they only compete on the quality of their product offerings, and won’t try to squash you like a bug because it’s easier than competing.
Take a low-margin business and make it better because now it’s online. Like shipping heavy boxes of cat litter UPS instead of selling it at stores because the internet loves cats.
Insert our company between buyers and sellers and take a taste of every transaction. If we reduce friction, we can take all of that as profit, rather than share it with customers. OK, this one works pretty well. I just hate the idea of it. Getting harder to find places to do this. There is generally a very powerful giant in this position in most industries.
I know how to build an anti-spin reticulator (whatever that is), so lets get rich selling anti-spin reticulators. After all, there must be a tremendous unmet need for anti-spin reticulators, because I know how to build one. This plan generally fails for not checking out the size of the total worldwide market for reticulators of all kinds.

<br><br>

I don’t think what a lot of “prestigious” companies do is very impressive.

Facebook? It’s a social media company, that’s it. Uber? It’s a cab company with a nice app and interesting ways of avoiding labour laws—and even loses money. Google’s real business is selling advertising.

I find it amazing that people talk about the “engineering” that happens at these companies, but don’t really consider what goes into say, Facebook, and what goes into, for example, Final Cut Pro. If you had a month, do you think you could make a Facebook clone? Just a basic one? Do you think you could make a Final Cut Pro clone? Just a basic one?

I think the level of hero worship surrounding websites with ads on is amazing. Yes, there are scaling issues, but lets not pretend that this is some kind of problem which is insurmountable by mere mortals, credit card companies have been solving it for decades. Scaling issues weren’t invent by social media companies, they weren’t even invented by the web. “Scaling” isn’t a magic word which makes us all fold our arms and look at each other sagely nodding. It’s just another problem which software companies solve, day in, day out.

I don’t see any innovation in GNU/Linux.

I think it’s a good OS, I’m building a startup on it right now, but it’s not innovative, it’s just a practical choice. GNU/Linux is an unashamed copy of something else, I’m not aware of any technical innovation which has come out of it.

I think Open Source has caused enormous damage.

Either we want to make money out of software or we don’t. If we do, then we either need to charge money for it, or we make money elsewhere, like advertising or support contracts. Advertising can be grubby and horrible, and support contracts don’t suit everything (how many software support contracts have you bought? Exactly.).

I think Open Source has achieved wonderful things like the survival of Operating Systems like RISC OS, Plan 9, and Inferno, and I’d like to see it push more realistic pricing of other great systems like IBM i, but the demonetisation of many industries is going to push efforts out of systems design and into monetisable industries like advertising. We shouldn’t pretend that this hasn’t already happened.

I’m not against Open Source, I just take a realistic view that software developers may wish to make money by making stuff and selling it. I’m aware of support contracts and the like, but again, how many things do we think we can give away and hope people pay for support? How does that even encourage easy to use and dependable software if your revenue source depends on people needing help with it?

<br><br>

Oh jeez, here we go…

Python - It’s OK, no more than that. Very overrated.

Language Fluency - I don’t want to hurt any feelings, but if you tell me you’re fluent in Java/Python/Swift/whatever, I’m going to assume you’re not a very good programmer. Don’t use that word.

Comp Sci - If you want to be a computer scientist, yes, go get that degree, if you want to be a programmer, do software engineering, it’s not the same thing….

JS - I don’t care if you think Node is good. It can’t be. It uses JS, therefore it’s awful.

Linux - You don’t need to use Linux to be a good programmer.

Performance - Performance is one of the least important metrics in languages, outside of game development, it rarely matters at all. Ever.

OOP - OOP is good. If you don’t think so, you’re using it wrong.

Java - Java isn’t cool, but it’s still one of best languages ever made.

Finally, to complete the rant, it doesn’t matter what you know, it doesn’t matter what you’ve mastered, you need to be able to make stuff, if you can’t make stuff, you’re not a programmer…

<br><br>

I think that Agile programming sucks the joy out of software development. There, I said it. I just had to get that off my chest.

Daily scrums, endless statusing, and the continuous integration treadmill makes me feel both micromanaged and that I, in turn, have to micromanage my team. Does every damn line of code need to be “grown in the garden”? How about giving us a bit of breathing room here? Oh no, I went to the restroom for too long so now my “earned value” is in the dumps!!! Give me a break. And I like unit testing but my code coverage better be over 96% or we are taking you to the woodshed. And don’t even get me started on the stupidity of cyclomatic complexity! Who was the genius who equated each case in a switch statement as a cycle! ARRRRRRGGGHHHHH!!!

Ok, ok … I feel better now. I have to pull myself together before my scrum, then the scrum of scrums (I kid you not) and then to check Version One, Gerrit, Jenkins, Jacoco, and … before I can get any real work done… and … uh oh, I feel the rage bubbling up again!!!!!!!!!!!!
